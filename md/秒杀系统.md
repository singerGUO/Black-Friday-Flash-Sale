# concepts

QPS 即**Queries Per Second**

MySQL 数据库单点能支撑 1000 QPS，但是 Redis10 W

"原子操作(atomic operation)是不需要synchronized"，这是多线程编程的老生常谈了。 所谓原子操作是指**不会被线程调度机制打断的操作**；这种操作一旦开始，就一直运行到结束，中间不会有任何context switch （切换到另一个线程）。

## My batis 逆向生成

这里要配置mybatis 生成器和数据的连接配置

生成后 resources 有XML 的数据库映射文件

另外会生成相应的main 底下mapper 操作文件

#### PO类

```
domainObjectName 对应po类
```

**这个Po类里可以理解成一个entity，然后可以直接调用**

**例如 在秒杀系统里 秒杀活动服务的 create order 方法 调用Order order = new Order();** 

#### Mapper 里的*.XML

```
1、首先定义一个sql标签，一定要定义唯一id<sql id="Base_Column_List" >字段名1,字段名2</sql>
2、然后通过id引用
<select id="selectAll">
select
<include refid="Base_Column_List" />
    from 表名
</select>

这时<include refid="Base_Column_List" />会自动把上面的代码贴过来。

数据库中查询的语句就可以解析为：select 字段名1，字段名2  from 表名
```

**已经定义了，相当于***

```xml
<sql id="Base_Column_List">
    id, name, commodity_id, old_price, seckill_price, activity_status, start_time, end_time, 
    total_stock, available_stock, lock_stock
  </sql>
```



## 启动类 自动扫描生成到的包

**在application 那里导入就好**

**一个是mapperScan** 

**一个是componentScan**

```
@MapperScan("com.zhenghao.seckill.db.mappers")
@ComponentScan(basePackages = {"com.zhenghao"})
```

## Properties 配置数据库连接

```java
#配置端口 tomcat

JDBC 驱动

datasource.url = mysql 地址/<数据库名>

username

password

#mybatis 

数据库映射的位置（resources底下的）

mybatis.mapper-locations:classpath:mappers/*.xml


```

**单元测试数据库连接，看是否能更新表**

## DAO 配置

**DAO数据访问层是处理业务代码，在MAPPER 上包了一层，**

**DAOImpl.java 里overvide DAO接口 的方法， DAOImpl.java 注入mapper 通过XXmapper.xml 方法访问数据库**

**（需要@resource 注入mapper 的底层代码）**



## Jmeter

可以并行的短时间发送多个请求

## 并行错误

**可以并行执行select 语句的，**

**但是update不可以并行执行，update 语句是串行的**

**容易出现错误**


![](spring_image/image-20221231170032150.png)

![image-20221231170032150](spring_image/image-20221231170032150.png)






### 乐观锁

**在update 的时候基于数据库 增加判断库存statement**

**大量的请求到数据库，容易crash**

![image-20221231165813499](spring_image/image-20221231165813499.png)

### **lua 脚本 redis** 

Redis 启动



**高效的组合多个命令，redis 挡住大部分请求，保护数据库**

**lua脚本合并select 和update 操作**

**创建订单的时候也会锁定订单double check**

**redis 读取lua 脚本**

**用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)**

```java
  String script = "if redis.call('exists',KEYS[1]) == 1 then\n" +
                    "                 local stock = tonumber(redis.call('get', KEYS[1]))\n" +
                    "                 if( stock <=0 ) then\n" +
                    "                    return -1\n" +
                    "                 end;\n" +
                    "                 redis.call('decr',KEYS[1]);\n" +
                    "                 return stock - 1;\n" +
                    "             end;\n" +
                    "             return -1;";
```



## 整体流程

![image-20230101182244715](spring_image/image-20230101182244715.png)



### RocketMQ 流量冲击

削峰填谷

异步解耦

![image-20230101182702107](spring_image/image-20230101182702107.png)

![image-20230101182741826](spring_image/image-20230101182741826.png)

### 雪花算法

**26万个有序分布式无碰撞的ID**





![image-20230105010507867](spring_image/image-20230105010507867.png)

## 数据一致性

![](/spring_image/poll.png)

![](spring_image/rocketmq.png)

![](spring_image/delaymessage.png)

多个系统协作

订单：订单状态改为“已支付”

支付：会有一条支付成功的记录

一致性，多个系统之间数据库不同的，事务不能解决，事务是在同一个数据库中的问题

2、延迟消息

1. 普通的消息

   ​	消息的生产者-》消息队列中-》消息的消费者，立马消费消息

2. 延迟消息

   ​	生成订单，15分钟的支付时间，

   - 时间内完成-》付款成功，发货，库存扣减
   - 时间内没有完成-》支付失败，订单关闭，库存回滚

   生成订单，发延迟信息，15分钟后check 订单支付状态，已经付款状态什么都不做，未付款关闭订单

   消息的生产者-》消息队列中-》消息的消费者过一段时间才消费消息，对消费者不可见，延迟做一件事

   

4、 ROCKETMQ（java），kafak（也支持延迟消息）

消息存储在磁盘中，冗余存储

![](/spring_image/limituser.png)

MQ 的两种消费模式

1. 广播消息消费

   消费生产者-》 消息队列 ->消费者1

   ​										  ->消费者1

   ​									所有消费者都可以消费这个信息

2. 集群消息消费

   消息生产者-》消息队列

   ​												消费者组（consumergroup）

   ​												组1

   ​												  ->消费者1

   ​												  ->消费者2

   ​											      同一个消费者组只有一个可以消费

​														->消费者3

​												  	  ->消费者4

Redis 的库存和数据库同步

数据预热的时候放在redis 中就 ok，支付失败，只要订单关闭，需要把冻结的库存补回去 redis 中的库存 + 1

Redis 数据的持久化

RDB ：一段时间快照保存

AOF：所有命令记录

每隔十分钟可以同步一下redis 数据

### 限购

![](spring_image/redis set.png)

![](spring_image/redisset2.png)



![](spring_image/suodingkucun.png)

```
同步和异步通常用来形容一次方法的调用。

同步方法的调用必须等到该方法返回后才能继续接下来的行为。

异步方法更像一个消息传递，一旦调用就会立即返回，调用者可以继续接下来的操作，

而异步方法通常会在另一个线程中执行，不会妨碍调用者的工作。
```
